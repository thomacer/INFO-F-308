\documentclass[letterpaper]{article}
\usepackage{natbib,alifexi}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[tocage]{appendix}
\usepackage[frenchb]{babel}
\usepackage[T1]{fontenc}
\usepackage{placeins, latexsym, amssymb}
\usepackage[hidelinks]{hyperref}
\usepackage{url}

\title{Manipulations de grands entiers: arithmétique multiprécision}
\author{Thomas Perale\\
    \mbox{}\\\\
    Université Libre de Bruxelles, Département d'Informatique\\
    tperale@ulb.ac.be\\
}

\setlength{\parskip}{0.5em}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

L'arithmétique multiprécision offre des méthodes pour faire des opérations sur
des nombres d'une taille arbitraire. Pour résoudre des problèmes qui ont
besoins d'utiliser des techniques d'arithmétique multiprécision des librairies
existent. Par exemple \emph{GMP} et \emph{GNU MPFR} qui sont les plus
répendues elles implémentent toutes les deux plusieurs algorithmes pour faire
des opérations qui sont plus ou moins efficace selon le cas et moins naturelles
que ceux utilisé pour la simple précision.
Je m'attarderai ici sur les différents algorithmes utilisées pour faire de
de la multiplication multiprécision sur des entiers et me baserai ensuite sur
la librairie \emph{GMP} pour expliquer concrètement les méthodes employés pour
faire des opérations multiprécisions.

\section{Qu'est-ce que c'est l'artithmétique multiprécision}

L'arthmétique multiprécision regroupe toutes les techniques utilisé dans des
programmes pour résoudre des opérations sur des nombres de taille
arbitraire\cite{wikimultiprecision}.
Celle-ci s'oppose à l'arithmétique simple précision qui ne s'occupe que des
nombres entre 8 et 64 bits selon l'architecture de l'ordinateur où est executé
le programme, et dont les opérations sont des instructions du
processeurs\cite{wikimultiprecision}.

\section{Les opérations simple précision}

Les opérations simple précision sont régulièrement implémenté comme des
instructions processeurs ou sont émulés ce qui offre un avantage de rapidité.
Les opérations sont les suivantes\cite{wikialu}:

\begin{itemize}
  \item L'addition.
  \item L'addition avec report. Si l'addition dépasse la limite de
    l'architecture, c'est indiqué dans un report.
  \item La soustraction.
  \item La soustraction avec report.
  \item Incrementaion.
  \item Decrémentation.
  \item ET logique.
  \item OU logique.
  \item OU exclusif logique.
  \item Complément à un.
  \item Décalage à gauche ou à droite.
  \item Rotation
  \item Rotation avec report.
\end{itemize}

Ces opérations sont importante parce qu'elles sont à la base des algorithmes
utilisé pour les opérations multiprécisions.

\subsection{Représentation}

La représentation des nombres en simple précision est totalement dépendante de
l'architecture de l'ordinateur sur lesquels ces opérations sont executés.
Généralement les nombres entiers sont représenté dans les architectures actuels
sous forme d'un nombre binaire de 64 bits en complément à deux.

\section{L'arithmétique multiprécision}

L'arithmétique multiprécision offre des algorithmes pour les opérations moins
évidents que ceux en simple précision mais permets de résoudre des opérations
sur des nombres de taille arbitraire. Les représentations et les algorithmes et
les représentations ne sont plus ici contraint par l'architecture du processeur
ce qui permet de varier la représentation selon l'algorithme utilisé pour
l'opération.

\subsection{Représentation vectorielle}

Si les nombres sont plus grand que la limite imposé par l'architecture, afin de
faire de l'arithmétique multiprécision, les nombres peuvent être représenter
dans une forme vectorielle. C'est à dire que le nombre est représenter dans un
vecteur d'entier lorsqu'il y a un report celui-ci est ajouté à l'élément
suivant du vecteur.\\

Dans notre cas on leur donnera cette notation:

  $$u = (u_{2n-1} \dots u_1 u_0)$$

Pour bien montrer la division en plusieurs éléments dans un vecteur.

% TODO Schéma

\subsection{Représentation modulaire}

La représentation modulaire est utilisé parce qu'elle permet de ne pas
travailler sur les nombres eux-même mais sur les restes de leur division
\cite{wikiamodulaire}.\\

Si on utilise des numbres $(m_1, m_2, \dots m_r)$ premiers entre eux,
on peut facilement calculer

  $$u_1 = u \mod m_1$$
  $$u_2 = u \mod m_2$$
  $$\dots$$
  $$u_r = u \mod m_r$$

Et on retrouver $u$ à partir de $u_1, u_2, \dots, u_r$, ce qui
est une conséquence du \emph{théorème du reste chinois}.\\

L'arithmétique modulaire est particulièrement utile dans le domaine de la
cryptographie de part sa capacitée de réduire des nombres premiers entre eux à
des nombres de petite taille, où les opérations peuvent être executés
parallèlement car elle s'éffectue sur chaque module de manière indépendante.

\section{Algorithme des opérations multiprécisions}

\subsection{Représentation vectorielle}

\subsubsection{Addition}

L'algorithme pour résoudre une addition sous forme vectorielle est simple.
Il se base sur l'addition en simple précision tout en ayant l'avantage de
pouvoir faire des additions sur des nombres de taille arbitraire. \\

Pour additionner un nombre en représentation vectorielle on additionne chacun
des éléments du vecteur entre eux et on ajoute les reports éventuels à
l'élément suivant du vecteur. \\

La complexité de cet algorithme dépend du nombre d'élément dans le vecteur et
la réponse sera un vecteur de même taille que le plus grand des opérandes
utiliśe dans l'addition.\\

J'ai parlé ici de l'addition mais le principe est le même pour la soustraction
si les nombres sont représenté sous la forme d'un complément à deux, car il
permet d'effectuer les opérations sur des nombres négatif de la même
manière\cite{wikicomplementtwo}.

\subsubsection{Multiplications}

C'est la multiplication qui est au coeur de l'arithmétique multiprécision, car
plus le nombre est grand plus il existe des manières d'optimiser la
multiplication.\\

On pourrait de la même manière que pour l'addition utiliser la méthode
\emph{calcul écrit} ce qui pour la multiplication nous donne un algorithme de
complexité quadratique. En effet pour résoudre la multiplication d'un nombre de
taill $m$ par un nombre de taille $n$ il faut $cnm$ opérations (avec $c$ un
nombre constant d'opération).  Cette approche est tout à fait correct quand on
doit manipuler des petits nombres mais demande trop de ressource pour manipuler
des grand nombres, surtout lorsqu'il existe des alternatives.

\subsubsection{L'algorithme de karatsuba ou Toom-2}

Cet algorithme permet de résoudre la multiplication d'un nombre
$u = (u_{2n-1} \dots u_1 u_0)$ par un nombre $v = (v_{2n-1} \dots v_1 v_0)$
avec une complexitée de $\mathcal{O}(N^{\log{3}/\log{2}})$.\\

Afin d'y arriver, les nombres $u$ et $v$ sont divisés en deux parties de taille
égale:

  $$u = 2^{n} U_1 + U_0$$
  $$v = 2^{n} V_1 + V_0$$

Ce qui permet de résoudre la multiplication de la façon suivante

  $$uv = (2^{2n} + 2^n) U_1 V_1 + 2^n (U_1 - U_0) (V_0 - V_1) + (2^n + 1) U_0 V_0$$

Cette opération réduit un problème de complexité quadratique à 3 multiplications
ainsi que des \emph{shifts} et des additions.
L'algorithme a une complexité $\mathcal{O}(N^{\log{3}/\log{2}})$ ce  qui
correspond à $3$ multiplications sur des nombres $\frac{1}{2}$ fois plus petits
que les originaux\cite{gmplibkaratsuba}.

\subsubsection{L'algorithme Toom-3}

Toom-3 est un autre algorithme utilisé pour la multiplication de deux
entiers. Pour se faire, chaque opérande est divisé en 3 (là où karatsuba
divisait en 2) partie de taille égale afin d'être traité comme le
coefficient de deux polynomes\cite{gmplib2014}.

    $$X(t) = x_2 t^2 + x_1 t + x_0$$
    $$Y(t) = y_2 t^2 + y_1 t + y_0$$

Le résultat de la multiplication aura donc la forme suivante

    $$W(t) = X(t) Y(t) =  w_4 t^4 + w_3 t^3 + w_2 t^2 + w_1 t + w_0$$

L'approche \emph{naive} de résoudre \emph{X (t) * Y (t)} pourrait être utilisée
mais celle-ci n'apporte aucun avantage en ce qui concerne la complexité de
l'algorithme par rapport à une multiplication classique.\cite{gmplib2014}
\newline
Les polynomes de degré \emph{d} sont définis par \emph{d + 1} points. Cette
propriété est utilisée par l'algorithme pour réduire le nombre d'opération, en
évaluant le polynome en $0, 1, -1, -2, \infty$ ce qui enlève des multiplications
à l'opération $X(t) Y(t)$\cite{wikitoom3}

    $$X (0) = x_{0} + x_{1} (0) + x_2 {(0)}^{2} = x_{0}$$
    $$X(1) = x_0 + x_1(1) + x_2{(1)}^2 = x_0 + x_1 + x_2$$
    $$X(-1) = x_0 + x_1(-1) + x_2{(-1)}^2 = x_0 - x_1 + x_2$$
    $$X(2) = x_0 + x_1(2) + x_2{(2)}^2 = x_0 - 2 * x_1 + 4 * x_2$$
    $$X(\infty) = x_2$$

$$
\begin{pmatrix}
  W (0) \\
  W (1) \\
  W (-1) \\
  W (2) \\
  W (\infty) \\
\end{pmatrix}
 =
\begin{pmatrix}
  1 & 0 & 0 & 0 & 0 \\
  1 & 1 & 1 & 1 & 1 \\
  1 &-1 & 1 &-1 & 1 \\
  1 &-2 & 4 &-8 &16 \\
  0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}
\begin{pmatrix}
  W_4 \\
  W_3 \\
  W_2 \\
  W_1 \\
  W_0 \\
\end{pmatrix}
$$

$$
\begin{pmatrix}
  W_4 \\
  W_3 \\
  W_2 \\
  W_1 \\
  W_0 \\
 \end{pmatrix}
=
\begin{pmatrix}
  1 & 0 & 0 & 0 & 0 \\
  1 & 1 & 1 & 1 & 1 \\
  1 &-1 & 1 &-1 & 1 \\
  1 &-2 & 4 &-8 &16 \\
  0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}^{-1}
\begin{pmatrix}
  W (0) \\
  W (1) \\
  W (-1) \\
  W (2) \\
  W (\infty) \\
\end{pmatrix}
$$

$$
=
\begin{pmatrix}
  1 & 0 & 0 & 0 & 0 \\
  1 & 1 & 1 & 1 & 1 \\
  1 &-1 & 1 &-1 & 1 \\
  1 &-2 & 4 &-8 &16 \\
  0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}^{-1}
\begin{pmatrix}
  x_2y_2 \\
  (4x_2 + 2x_1 + x_0) (4y_2+ 2y_1 + y_0)\\
  (x_2 - x_1 + x_0) (y_2 - y_1 + y_0)\\
  (x_2 + x_1 + x_0) (y_2 + y_1 + y_0)\\
  x_0y_0\\
\end{pmatrix}
$$

\subsubsection{Les autres}

Comme on l'a vu les algorithmes précédent utilisent tous le même processus ils
divisent les opérandes en un certain nombre de parties de taille égales. Le
concept est extensible à l'infini ce qui permet de diminuer infiniment la
complexité de la multiplication. Le problème est que plus on augment le nombre
de partie utilisé pour diviser le nombre plus on doit effectuer des calculs
matriciels compliqués, ce qui fait que les nombres doivent être très grand pour
qu'on observe un gain de performance.

\subsection{Représentation modulaire}

\subsubsection{Addition}

L'addition l'addition se résout de la façon suivante en représentation
modulaire.

\begin{equation}
  \begin{split}
    (u_1, \dots, u_r) + (v_1, \dots, v_r) \\
     \Rightarrow ((u_1 + v_1) \bmod m_1, \dots, (u_r + v_r) \bmod m_r)
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    (u_1, \dots, u_r) - (v_1, \dots, v_r) \\
      \Rightarrow ((u_1 - v_1) \bmod m_1, \dots, (u_r - v_r) \bmod m_r)
  \end{split}
\end{equation}

Les désavantages sont qu'une représentation modulaire rend difficile de
déterminer si un nombre est positif ou négatif ou de savoir si
$(u_1, \dots, u_r)$ est plus grand que $(v_1, \dots, v_r)$.

\subsubsection{Multiplications}

De la même manière pour effectuer une multiplication entre deux nombre en
représentation modulaire

\begin{equation}
  \begin{split}
    X = U . V \mod M
  \end{split}
\end{equation}

On peut la calculer de la sorte

\begin{equation}
  \begin{split}
    (u_1, \dots, u_r) X (v_1, \dots, v_r) \mod M \\
      \Rightarrow ((u_1 X v_1) \mod m_1, \dots, (u_r X v_r) \mod m_r)
  \end{split}
\end{equation}

\subsubsection{La réduction de montgomery}

La réduction de montgomery est un algorithme qui permet d'effectuer une
multiplication modulaire de manière efficace\cite{menezes1996crypto}.\\

Soit un entier $n$ strictement positif et $R$ et $T$ des entiers tel que $R >
n$ et $pgcd(R, n) = 1$ et $0 < T < Rn$, la réduction de montgomery est la
méthode utilisé pour resoudre $T R^{-1} \mod n$, selon le choix de $R$ la
réduction peut être calculer de manière efficace\cite{menezes1996crypto}.\\

La forme \emph{montgomery} d'une multiplication de $u$ par $v$ est la
suivante

$$(uR \bmod N)(vR \bmod N) R' ≡ (uR)(vR) R' ≡ (u.v) R \pmod N$$

Avec un entier $R'$ qui résout $RR' = 1 \pmod N$.\\

La réduction de montgomery est totallement adapté pour résoudre des opérations
en multiprécision car il permet de réduire la taille des nombres sur lesquelles
on fait des opérations. Typiquement une implémentation de l'algorithme de
montgomery s'assurerra que $R$ soit égale à $R = b^{x}$ ($b$ étant la base utilisé,
c'est à dire 2 dans le cadre d'un ordinateur et $x$ un nombre pour que
$pgcd(R, n) = 1$) pour que les opérations intermédiaire peuvent être résolue
grace à des \emph{shifts}\cite{djguan2003montgomery}.

% $$RR' - NN' = 1$$

% u = 7
% v = 15
% N = 17
% R = 100
% (7.100 mod 17 = 3) and (15.100 mod 17 = 4) et 3.4 = 12
% RR' - NN' =  8⋅100 − 47⋅17 = 1, -> R' = 8 et N' = 47
% (uR.vR).R' mod 17 = 12*8 mod 17 = 96 mod 17 = 11

\section{La librairie GMP}

\subsection{Introduction}

La librairie \emph{GMP} (GNU Multiple Precision Arithmetic Library) est une
librairie libre permettant d'effectuer de l'arithmétique multiprécision sur
des entiers, comme sur des nombres rationnels. Elle a la particularité de ne pas
avoir de limite de précision, si ce n'est celle de la mémoire.
\newline
Cette librairie est souvent utilisée pour des applications liées à la
cryptographie\cite{wikigmp}.

\subsection{Quel algorithme utiliser}

Les sections précédentes nous ont montré qu'on pouvait récursivement
infiniment diminuer la complexité des algorithmes de multiplication.
Il est légitime de se demander pourquoi ne pas utiliser l'algorithme
qui a la complexité la plus petite et quel algorithme utiliser dans
quelle situation.
\newline
La réponse à la première question est que ces algorithmes deviennent
plus rapides à partir du moment ou les nombres multipliés sont
suffisamment large. Le nombre d'opération ayant un coût constant
très élevé pour résoudre l'algorithme, ceux-ci sont plus lents
que des algorithmes de multiplication basique (en $\mathcal{O}(n^2)$)
\newline
Pour ce qui est de choisir un algorithme adéquat à la multiplication,
la librairie GMP a choisi d'implémenter 7 algorithmes de multiplication
qui sont utilisés au fûr et à mesure que la taille de l'opération
augmente\cite{gmplibmultiplication}.

\begin{itemize}
  \item La multiplication basique
  \item Karatsuba
  \item Toom-3
  \item Toom-4
  \item Toom-6.5
  \item Toom-8.5
  \item FFT
\end{itemize}

La librairie implémente directement des \emph{seuils} pour lesquels
on passe d'une opération à l'autre. Ces seuils varient selon
beaucoup de paramètres dont l'architecture. Mais, en guise d'exemple
pour multiplier $N*N$, on peut, dans certains cas, commencer à utiliser
l'algorithme de \emph{Karatsuba} plutôt que la simple multiplication
à partir de $10^{10}$\cite{gmplibkaratsuba}.


\footnotesize
\bibliographystyle{apalike}
\bibliography{bibliography}

\end{document}
uer
