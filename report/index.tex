\documentclass[letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{natbib,alifexi}
\usepackage{amsmath}
\usepackage{url}

\title{Manipulations de grands entiers: arithmétique multiprécision}
\author{Thomas Perale\\
    \mbox{}\\\\
    Université Libre de Bruxelles, Département d'Informatique\\
    tperale@ulb.ac.be\\
}

\setlength{\parskip}{0.5em}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}

L'arithmétique multiprécision offre des méthodes pour faire des opérations sur
des nombres d'une taille arbitraire.
Les algorithmes de multiprécision sont particulièrement utiles lorsqu'ils sont
executé pour faire des opérations sur un ordinateur.
Le problème est relativement trivial pour l'addition et la soustraction car
la taille du résultat d'une opérations de deux entiers de taille \emph{n} est
toujours de \emph{n} avec un report éventuelle.
L'arithmétique multiprécision prend tout son sens lors de la multiplication,
car la multiplication d'un entier de taille \emph{m} par un entier de taille
\emph{n} donne une réponse de taille \emph{(m + n)} en utilisant des
algorithmes classiques\cite{knuth1997aocp}.

\section{État de l'art}

\subsection{Méthode classique}

Les méthodes classique, sont décrites comme l'ensemble des méthodes primitives
d'un ordinateur\cite{knuth1997aocp}, c'est à dire:

\begin{itemize}
    \item L'addition ou soustraction de deux entiers de taille (n) qui donne
        un résultat de la même taille avec un report éventuelle.
    \item La multiplication d'un entier de taille (n) avec un autre de taille
        (m) qui donne un résultat de taille (n + m).
    \item La division d'un entier d'une taille (m) par un autre d'une taille
        (n) qui donne un résultat d'une taille (m) avec un reste éventuel de
        taille (m).
\end{itemize}

Les algorithmes des méthodes primitives sont identiques à celles qu'on effectue
pour résoudre un calcul à l'aide de la méthode \emph{calcul écrit} sur papier
\cite{knuth1997aocp}.

\subsubsection{Algorithme de multiplication classique}

L'algorithme classique de la multiplation pour deux entiers $u X v$ avec
$u = (u_1, u_2, \dots u_n)$ et $v = (v_1, v_2, \dots v_m)$ est basé la
création de produit partiel $(u_1, u_2, u_3, \dots, u_n) X v_j$ pour
$0 <= j <= m$  et en suite ajouter ces produits ensemble en utilisant la
bonne base pour chacun d'eux.

% Les méthodes qui vont suivre seront toutes construites sur base de ces trois
% opérations primitives.

\subsection{Arithmétique modulaire}

Il existe une autre manière existe de faire des opérations sur des grands nombres
en utilisant l'arithmétique modulaire qui consiste à ne pas travailler sur les
nombres eux-même mais sur les restes de leur division\cite{wikiamodulaire}.\\

Si on utilise plusieurs \emph{moduli} $(m_1, m_2, \dots m_r)$ qui sont premier
entre eux on peut facilement calculer

  $$u_1 = u \mod m_1$$
  $$u_2 = u \mod m_2$$
  $$\dots$$
  $$u_r = u \mod m_r$$

Et on peut retrouver $u$ à partir de $u_1, u_2, \dots, u_r$, ce qui
est une conséquence du \emph{théorème du reste chinois}.\\

Dés lors on peut représenter les opérations de la manière suivante.

  $$(u_1, \dots, u_r) + (v_1, \dots, v_r) = ((u_1 + v_1) \mod m_1, \dots, (u_r + v_r) \mod m_r),$$
  $$(u_1, \dots, u_r) - (v_1, \dots, v_r) = ((u_1 - v_1) \mod m_1, \dots, (u_r - v_r) \mod m_r),$$
  $$(u_1, \dots, u_r) X (v_1, \dots, v_r) = ((u_1 X v_1) \mod m_1, \dots, (u_r X v_r) \mod m_r),$$

Les désavantages sont qu'une représentation modulaire rend difficile de
déterminer si un nombre est positif ou négatif ou de savoir si $(u_1, \dots, u_r)$
est plus grand que $(v_1, \dots, v_r)$.

% \subsubsection{Théorème du reste chinois}

\subsubsection{Quand l'utiliser}

L'arithmétique modulaire offre réellement des avantages lorsqu'il s'agit de faire
des multiplications sur des grands nombres combiné avec des additions ou
soustractions, mais pas lorsqu'il faut diviser ou comparer.

\subsection{Diminuer la complexité des algorithmes}

Les méthodes précédentes présentait des algorithmes qui avaient besoin de cnm operations pour multiplier un nombre de taille
$m$ par un nombre de taille $n$ (c un nombre constant d'opération). Cette section aborde rapidement les méthodes pour faire
une multiplication en moins d'opération. \\

Pour multiplier deux nombres $u = (u_{2n-1} \dots u_1 u_0)$ et $v = (v_{2n-1} \dots v_1 v_0)$ de la même taille, qu'on peut
écrire sous la forme

  $$u = 2^{n} U_1 + U_0$$
  $$v = 2^{n} V_1 + V_0$$

$U_1$ étant la moitiée la plus grande de $u$ (identique pour $V_1$ avec v) et $U_0$ la moitiée la plus petite (identique pour
$V_0$ avec $v$). On peut écrire

  $$uv = (2^{2n} + 2^n) U_1 V_1 + 2^n (U_1 - U_0) (V_0 - V_1) + (2^n + 1) U_0 V_0$$

Cette opération réduit un problème de complexité quadratique à 3 multiplications avec des \emph{shifts} et des additions. Il
s'agit de l'algorithme de \emph{karatsuba} sont implémentation sera abordé plus tard.\\

Même si cette méthode peut être utilisé sur les machines pour executer une
multiplication plus rapidement qu'avec la méthode traditionelle, son vrai
avantage est qu'on peut l'utiliser pour définir de manière récursive un
algorithme de multiplication.

% Expliquer qu'ici on divise par 2 les nombres mais on peut faire la même si on
% divise par 3 le nombre, etc ..

\section{La librairie GMP}
% Regarder comment knuth introduit TOOM.
\subsection{Introduction}

La librairie \emph{GMP} (GNU Multiple Precision Arithmetic Library) est une
librairie libre permettant d'effectuer de l'arithmétique multiprécision sur
des entiers, comme sur des nombres rationnels. Elle a la particularité de ne pas
avoir de limite de précision, si ce n'est celle de la mémoire.
\newline
Cette librairie est souvent utilisé pour des applications liées à la cryptographie
\cite{wikigmp}.

\subsection{Karatsuba ou Toom-2}

Comme expliquer dans la section précedente \emph{l'algorithme de Karatsuba} sert
à résoudre la multiplication d'un nombre $u = (u_{2n-1} \dots u_1 u_0)$ par un
nombre $v = (v_{2n-1} \dots v_1 v_0)$. Afin d'y arriver les nombres $u$ et $v$
sont divisé en deux partie de taille égale

  $$u = 2^{n} U_1 + U_0$$
  $$v = 2^{n} V_1 + V_0$$

Ce qui permet de résoudre la multiplication de la façon suivante

  $$uv = (2^{2n} + 2^n) U_1 V_1 + 2^n (U_1 - U_0) (V_0 - V_1) + (2^n + 1) U_0 V_0$$

Pour donnee un algorithme de complexité $\mathcal{O}(N^{\log{3}/\log{2}})$ qui
correspond à $3$ multiplications sur des nombre $\frac{1}{2}$ plus petit que
les originaux\cite{gmplibkaratsuba}.

\subsection{La multiplication Toom-3}

Toom-3 est un algorithme utilisé pour la multiplication de deux très grands
entiers. Pour se faire chaque opérande est divisé en 3 (là où karatsuba
divisait en 2) partie de taille égale afin d'être traité comme le
coefficient de deux polynomes\cite{gmplib2014}.

    $$X(t) = x_2 t^2 + x_1 t + x_0$$
    $$Y(t) = y_2 t^2 + y_1 t + y_0$$

Le résultat de la multiplication aura donc la forme suivante

    $$W(t) = X(t) Y(t) =  w_4 t^4 + w_3 t^3 + w_2 t^2 + w_1 t + w_0$$

L'approche \emph{naive} de résoudre \emph{X (t) * Y (t)} pourrait être utilisé
mais celle-ci n'apporte aucun avantage en ce qui concerne la complexitée de
l'algorithme par apport à une multiplication classique.\cite{gmplib2014}
\newline
Les polynomes de degrée \emph{d} sont défini par \emph{d + 1} points. Cette
propriété est utilisé par l'algorithme pour réduire le nombre d'opération, en
évaluant le polynome en 0, 1, -1, -2, $\infty$ ce qui enlève des multiplications
à l'opérations $X(t) Y(t)$\cite{wikitoom3}

    $$X (0) = x_{0} + x_{1} (0) + x_2 {(0)}^{2} = x_{0}$$
    $$X(1) = x_0 + x_1(1) + x_2{(1)}^2 = x_0 + x_1 + x_2$$
    $$X(-1) = x_0 + x_1(-1) + x_2{(-1)}^2 = x_0 - x_1 + x_2$$
    $$X(2) = x_0 + x_1(2) + x_2{(2)}^2 = x_0 - 2 * x_1 + 4 * x_2$$
    $$X(\infty) = x_2$$

$$
\begin{pmatrix}
  W (0) \\
  W (1) \\
  W (-1) \\
  W (2) \\
  W (\infty) \\
\end{pmatrix}
 =
\begin{pmatrix}
  1 & 0 & 0 & 0 & 0 \\
  1 & 1 & 1 & 1 & 1 \\
  1 &-1 & 1 &-1 & 1 \\
  1 &-2 & 4 &-8 &16 \\
  0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}
\begin{pmatrix}
  W_4 \\
  W_3 \\
  W_2 \\
  W_1 \\
  W_0 \\
\end{pmatrix}
$$

$$
\begin{pmatrix}
  W_4 \\
  W_3 \\
  W_2 \\
  W_1 \\
  W_0 \\
 \end{pmatrix}
=
\begin{pmatrix}
  1 & 0 & 0 & 0 & 0 \\
  1 & 1 & 1 & 1 & 1 \\
  1 &-1 & 1 &-1 & 1 \\
  1 &-2 & 4 &-8 &16 \\
  0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}^{-1}
\begin{pmatrix}
  W (0) \\
  W (1) \\
  W (-1) \\
  W (2) \\
  W (\infty) \\
\end{pmatrix}
$$

$$
=
\begin{pmatrix}
  1 & 0 & 0 & 0 & 0 \\
  1 & 1 & 1 & 1 & 1 \\
  1 &-1 & 1 &-1 & 1 \\
  1 &-2 & 4 &-8 &16 \\
  0 & 0 & 0 & 0 & 1 \\
\end{pmatrix}^{-1}
\begin{pmatrix}
  x_2y_2 \\
  (4x_2 + 2x_1 + x_0) (4y_2+ 2y_1 + y_0)\\
  (x_2 - x_1 + x_0) (y_2 - y_1 + y_0)\\
  (x_2 + x_1 + x_0) (y_2 + y_1 + y_0)\\
  x_0y_0\\
\end{pmatrix}
$$

\subsection{Les autres Toom}

Les versions supérieurs reprennent le même principe mais en divisant
en plus de partie de taille égale.

\subsection{Quel algorithme utiliser}

Les sections précédentes nous ont montré qu'on pouvait récursivement
infiniment diminuer la complexitée des algorithmes de multiplications.
Il est légitime de se demander pourquoi ne pas utiliser l'algorithme
qui a la complexité la plus petite et quel algorithme utiliser dans
quel situation.
\newline
La réponse à la première question est que ces algorithmes deviennent
plus rapide à partir du moment ou les nombres multiplié sont
suffisament large. Le nombre d'opération ayant un cout constant
étant très élevé pour résoudre l'algorithme ceux-ci sont plus lent
que des algorithmes de multiplications basique (en $\mathcal{O}(n^2)$)
\newline
Pour ce qui est de choisir un algorithme adéquat à la multiplication,
la librairie GMP a choisit d'implémenter 7 algorithme de multiplication
qui sont utiliser au fûr et à mesure que la taille de l'opération
augmente\cite{gmplibmultiplication}.

\begin{itemize}
  \item La multiplication basique
  \item Karatsuba
  \item Toom-3
  \item Toom-4
  \item Toom-6.5
  \item Toom-8.5
  \item FFT
\end{itemize}

La librairie implémente directement des \emph{seuils} pour lesquels
on passe d'une opération à l'autre. C'est seuils varient selon
beaucoup de paramètre dont l'architecture. Mais en guise d'exemple
pour multiplier $NxN$ on peut dans certains cas commencer à utiliser
l'algorithme de \emph{Karatsuba} plutôt que la simple multiplication
à partir de $10^{10}$\cite{gmplibkaratsuba}.

\end{document}

\footnotesize
\bibliographystyle{plain}
\bibliography{bibliography}
